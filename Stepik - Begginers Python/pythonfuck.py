#python3
# -*- coding: utf-8 -*-

''' Задание: Выведите таблицу размером n×n, заполненную числами от 1 до n**n по спирали,
 выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере (здесь n=5):
Sample Input:
5
Sample Output:

1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9

 '''

number = int(input())                                             # Создаем матрицу
check = number ** 2                                               # Создаем контрольную сумму для выхода из while
matrix = [[0 for egg in range(number)] for foo in range(number)]  # Заполняем матрицу нолями
''' Создаем переменные, контролирующие проход матрицы по спирали. Они используются как константы для конкретного прохода,
после прохода они итерируются на необходимую величину. '''
firstouter = 0
firstinner =  number - 1
secondouter = -1
secondinner = -(number)
''' Создаем счетчики. Первый - это число, записываемое в ячейки матрицы, после каждой записи итерируется на 1, пока не 
достигнет контрольного значения (check). 
Второй итератор нужен для правильного обхода внутренних "петель" матрицы. Он смещает координаты так, чтобы не проходить
вновь по ее внешним "петлям".'''
count = 1
cycle = 1
''' Это проход первой строки. При заданных условиях и выбранном мною методе обхода матрицы обнаруживаются следующие 
 закономерности:
 - любой n**2 можно представить как n + n-1 + n-1 + n-2 + n-2 + ... + n-(n-1) + n-(n-1)
 - Как можно заметить, первая строка уникальна по размеру.
 - Все прочие строки (проходы) повторяются два раза, вплоть до конца уравнения.
 Следовательно, чтобы не возникло проблем, мы отделим первый цикл от прочих (хотя можно в будущем оптимизировать это
 дерьмо так, чтобы просто исключение в первом проходе делалось), а остальные заключим в цикл while, который контролирует 
 выполенние главных условий задачи'''
for first in range(number):
    matrix[firstouter][first] = count
    count += 1
    if number == first+1: # то есть: если цикл делает последнюю итерацию
        firstouter += 1
number -= 1 # Эта операция ограничивает количество проходов так, чтобы циклы не выходили за границы матрицы.

while count <= check: # Наш счетчик не должен превысить контрольную сумму
    ''' Проходим сверху вниз правую сторону петли'''
    for second in range(number):
        matrix[second+cycle][firstinner] = count
        count += 1
        if number == second+1: # то есть: если цикл делает последнюю итерацию
            firstinner -= 1    # эта инкрементация нужна для правильного перехода на следующую "петлю"
    ''' Проходим справа налево нижнюю сторону петли'''
    for third in range(number):
        matrix[secondouter][-(third)-(cycle+1)] = count
        count += 1
        if number == third+1: # то есть: если цикл делает последнюю итерацию
            secondouter -= 1  # эта инкрементация нужна для правильного перехода на следующую "петлю"
    number -= 1 # Эта операция ограничивает количество проходов так, чтобы циклы не выходили за границы матрицы.

    if count > check:
        break
    ''' Проходим снизу вверх левую сторону петли'''
    for four in range(number):
        matrix[-(four)-(cycle+1)][secondinner] = count
        count += 1
        if number == four+1: # то есть: если цикл делает последнюю итерацию
            secondinner += 1 # эта инкрементация нужна для правильного перехода на следующую "петлю"
    ''' Проходим слева направо верхнюю сторону следующей петли
        Здесь также есть одна особенность - в этой итерации мы уже заходим на новый круг. Только после этого цикла
        мы можем изменить размер шага "петли" и начать новый большой цикл. '''
    for fifth in range(number):
        matrix[firstouter][fifth+cycle] = count
        count += 1
        if number == fifth + 1:  # то есть: если цикл делает последнюю итерацию
            firstouter += 1      # эта инкрементация нужна для правильного перехода на следующую "петлю"

    number -= 1 # Эта операция ограничивает количество проходов так, чтобы циклы не выходили за границы матрицы.
    cycle += 1 # Завершаем обработку "петли" и переходим на следующую.

# делаем красивый вывод нашей змейки
for row in matrix:
    print(' '.join([str(elem) for elem in row]))